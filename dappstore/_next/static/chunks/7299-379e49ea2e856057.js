"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7299],{15911:function(e,n,t){t.d(n,{HM:function(){return o},WF:function(){return l},cN:function(){return u},uc:function(){return i},x$:function(){return s}});var a=t(70794);t(76718);var r=t(87066);function o(e,n,t){if(!(n>0))return new a.Z(String(e)).toFixed(t);{let r=new a.Z(String(e)),o=new a.Z(String(10)).exponentiatedBy(String(n));return new a.Z(r.dividedBy(o)).toFixed(t)}}function i(e){return/^0x[a-fA-F0-9]{40}$/.test(e)}function s(e,n,t){if(!(n>0))return new a.Z(String(e)).toFixed(t);{let r=new a.Z(String(e)),o=new a.Z(String(10)).exponentiatedBy(String(n));return new a.Z(r.multipliedBy(o)).toFixed(t)}}let u=e=>Number(e)>0&&Number.isInteger(Number(e)),l=async(e,n,t,a,o,i,s,u)=>{let l=t.slice(2),d={apikey:s.etherscanApiKey,module:"contract",action:"verifysourcecode",contractaddress:e,codeformat:"solidity-single-file",contractname:u,compilerversion:"v0.8.21+commit.d9974bed",optimizationUsed:"0",constructorArguements:l,sourceCode:n,runs:200},c=new FormData;c.append("apikey",s.etherscanApiKey),c.append("module","contract"),c.append("action","verifysourcecode"),c.append("contractaddress",e),c.append("codeformat","solidity-single-file"),c.append("contractname",u),c.append("compilerversion","v0.8.21+commit.d9974bed"),c.append("optimizationUsed","0"),c.append("constructorArguements",l),c.append("sourceCode",n),c.append("runs",200);try{(async(e,n)=>{let t=0;window.localStorage.setItem("tokenInfo",JSON.stringify(d)),console.log(d,"verification body");let u=async()=>{try{let l=await r.Z.post(s.etherscanApiUrl,c,{headers:{"Content-Type":"multipart/form-data"}});console.log(l),"0"===l.data.status&&t<5?(t++,setTimeout(u,12e3)):"0"===l.data.status&&4===t?(a("Contract couldn't verify : ".concat(e.logs[0].address)),i("Please contact us as soon as possible"),o(!1)):n(e)}catch(e){console.error("Hata oluştu:",e)}};u()})(d,e=>{console.log("////////////CONTRACT VERIFIED/////////"),a("Your Contract Verified"),i("You can go back home or create new token."),o(!1)})}catch(e){console.error("Hata oluştu:",e)}}},54116:function(e,n,t){t.d(n,{u:function(){return a}});let a={fees:{standardToken:{1:"15000000000000000",56:"77000000000000000",97:"100000000000000000",8453:"15000000000000000",137:"80000000000000000000",10:"15000000000000000",42161:"15000000000000000"},pausableToken:{1:"20000000000000000",56:"105000000000000000",97:"1000",8453:"20000000000000000",137:"100000000000000000000",10:"20000000000000000",42161:"20000000000000000"},blacklistToken:{1:"20000000000000000",56:"105000000000000000",97:"1000",8453:"20000000000000000",137:"100000000000000000000",10:"20000000000000000",42161:"20000000000000000"},ultimateToken:{1:"25000000000000000",56:"135000000000000000",97:"1000",8453:"25000000000000000",137:"120000000000000000000",10:"25000000000000000",42161:"25000000000000000"}}}},17299:function(e,n,t){t.d(n,{Z:function(){return s}});var a=t(69116),r=t(15911),o=t(54116);let i={standardToken:{1:{deployFee:o.u.fees.standardToken["1"],routerAddress:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",routerName:"Uniswap v2",currencyName:"ETH",explorerUrl:"https://etherscan.io/"},56:{deployFee:o.u.fees.standardToken["56"],routerAddress:"0x10ED43C718714eb63d5aA57B78B54704E256024E",routerName:"Pancakeswap v2",currencyName:"BNB",explorerUrl:"https://bscscan.com/"},8453:{deployFee:o.u.fees.standardToken["8453"],routerAddress:"0xaaa3b1F1bd7BCc97fD1917c18ADE665C5D31F066",routerName:"Swap Based v2",currencyName:"ETH",explorerUrl:"https://basescan.org/"},97:{deployFee:o.u.fees.standardToken["97"],routerAddress:"0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3",routerName:"Uniswap v2",currencyName:"BNB",explorerUrl:"https://testnet.bscscan.com/"},137:{deployFee:o.u.fees.standardToken["137"],routerAddress:"0xedf6066a2b290C185783862C7F4776A2C8077AD1",routerName:"Pancakeswap v2",currencyName:"MATIC",explorerUrl:"https://polygonscan.com/"},10:{deployFee:o.u.fees.standardToken["10"],routerAddress:"0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"},42161:{deployFee:o.u.fees.standardToken["42161"],routerAddress:"0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"}},pausableToken:{1:{deployFee:o.u.fees.pausableToken["1"],routerAddress:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",routerName:"Uniswap v2",currencyName:"ETH",explorerUrl:"https://etherscan.io/"},56:{deployFee:o.u.fees.pausableToken["56"],routerAddress:"0x10ED43C718714eb63d5aA57B78B54704E256024E",routerName:"Pancakeswap v2",currencyName:"BNB",explorerUrl:"https://bscscan.com/"},8453:{deployFee:o.u.fees.pausableToken["8453"],routerAddress:"0xaaa3b1F1bd7BCc97fD1917c18ADE665C5D31F066",routerName:"Swap Based v2",currencyName:"ETH",explorerUrl:"https://basescan.org/"},97:{deployFee:o.u.fees.pausableToken["97"],routerAddress:"0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3",routerName:"Uniswap v2",currencyName:"BNB",explorerUrl:"https://testnet.bscscan.com/"},137:{deployFee:o.u.fees.pausableToken["137"],routerAddress:"0xedf6066a2b290C185783862C7F4776A2C8077AD1",routerName:"Pancakeswap v2",currencyName:"MATIC",explorerUrl:"https://polygonscan.com/"},10:{deployFee:o.u.fees.pausableToken["10"],routerAddress:"0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"},42161:{deployFee:o.u.fees.pausableToken["42161"],routerAddress:"0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"}},blacklistToken:{1:{deployFee:o.u.fees.blacklistToken["1"],routerAddress:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",routerName:"Uniswap v2",currencyName:"ETH",explorerUrl:"https://etherscan.io/"},56:{deployFee:o.u.fees.blacklistToken["56"],routerAddress:"0x10ED43C718714eb63d5aA57B78B54704E256024E",routerName:"Pancakeswap v2",currencyName:"BNB",explorerUrl:"https://bscscan.com/"},8453:{deployFee:o.u.fees.blacklistToken["8453"],routerAddress:"0xaaa3b1F1bd7BCc97fD1917c18ADE665C5D31F066",routerName:"Swap Based v2",currencyName:"ETH",explorerUrl:"https://basescan.org/"},97:{deployFee:o.u.fees.blacklistToken["97"],routerAddress:"0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3",routerName:"Uniswap v2",currencyName:"BNB",explorerUrl:"https://testnet.bscscan.com/"},137:{deployFee:o.u.fees.blacklistToken["137"],routerAddress:"0xedf6066a2b290C185783862C7F4776A2C8077AD1",routerName:"Pancakeswap v2",currencyName:"MATIC",explorerUrl:"https://polygonscan.com/"},10:{deployFee:o.u.fees.blacklistToken["10"],routerAddress:"0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"},42161:{deployFee:o.u.fees.blacklistToken["42161"],routerAddress:"0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"}},ultimateToken:{1:{deployFee:o.u.fees.ultimateToken["1"],routerAddress:"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",routerName:"Uniswap v2",currencyName:"ETH",explorerUrl:"https://etherscan.io/"},56:{deployFee:o.u.fees.ultimateToken["56"],routerAddress:"0x10ED43C718714eb63d5aA57B78B54704E256024E",routerName:"Pancakeswap v2",currencyName:"BNB",explorerUrl:"https://bscscan.com/"},8453:{deployFee:o.u.fees.ultimateToken["8453"],routerAddress:"0xaaa3b1F1bd7BCc97fD1917c18ADE665C5D31F066",routerName:"Swap Based v2",currencyName:"ETH",explorerUrl:"https://basescan.org/"},97:{deployFee:o.u.fees.ultimateToken["97"],routerAddress:"0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3",routerName:"Uniswap v2",currencyName:"BNB",explorerUrl:"https://testnet.bscscan.com/"},137:{deployFee:o.u.fees.ultimateToken["137"],routerAddress:"0xedf6066a2b290C185783862C7F4776A2C8077AD1",routerName:"Pancakeswap v2",currencyName:"MATIC",explorerUrl:"https://polygonscan.com/"},10:{deployFee:o.u.fees.ultimateToken["10"],routerAddress:"0x4A7b5Da61326A6379179b40d00F57E5bbDC962c2",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"},42161:{deployFee:o.u.fees.ultimateToken["42161"],routerAddress:"0x4752ba5dbc23f44d87826276bf6fd6b1c372ad24",routerName:"Pancakeswap v2",currencyName:"ETH",explorerUrl:"https://optimistic.etherscan.io/"}}};var s=[{name:"Standard Token",description:"Customizable Tax Fee’s and Anti-Bot.",feeValidation:!0,maxFee:30,abi:a.Yf,bytecode:a._O,contractName:"StandardToken",deployFeeAddress:"0x370D71435cC9882bA5682C3B1387D5A252f0CF81",encodetypes:["string","string","address","address","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","address","address"],tokenCode:'// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n	event Transfer(address indexed from, address indexed to, uint256 value);\n\n	event Approval(address indexed owner, address indexed spender, uint256 value);\n\n	function totalSupply() external view returns (uint256);\n\n	function balanceOf(address account) external view returns (uint256);\n\n	function transfer(address to, uint256 amount) external returns (bool);\n\n	function allowance(address owner, address spender) external view returns (uint256);\n\n	function approve(address spender, uint256 amount) external returns (bool);\n\n	function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n	function name() external view returns (string memory);\n\n	function symbol() external view returns (string memory);\n\n	function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n	function _msgSender() internal view virtual returns (address) {\n		return msg.sender;\n	}\n\n	function _msgData() internal view virtual returns (bytes calldata) {\n		return msg.data;\n	}\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n	mapping(address => uint256) private _balances;\n\n	mapping(address => mapping(address => uint256)) private _allowances;\n\n	uint256 private _totalSupply;\n\n	string private _name;\n	string private _symbol;\n\n	constructor(string memory name_, string memory symbol_) {\n		_name = name_;\n		_symbol = symbol_;\n	}\n\n	function name() public view virtual override returns (string memory) {\n		return _name;\n	}\n\n	function symbol() public view virtual override returns (string memory) {\n		return _symbol;\n	}\n\n	function decimals() public view virtual override returns (uint8) {\n		return 18;\n	}\n\n	function totalSupply() public view virtual override returns (uint256) {\n		return _totalSupply;\n	}\n\n	function balanceOf(address account) public view virtual override returns (uint256) {\n		return _balances[account];\n	}\n\n	function transfer(address to, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_transfer(owner, to, amount);\n		return true;\n	}\n\n	function allowance(\n		address owner,\n		address spender\n	) public view virtual override returns (uint256) {\n		return _allowances[owner][spender];\n	}\n\n	function approve(address spender, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, amount);\n		return true;\n	}\n\n	function transferFrom(\n		address from,\n		address to,\n		uint256 amount\n	) public virtual override returns (bool) {\n		address spender = _msgSender();\n		_spendAllowance(from, spender, amount);\n		_transfer(from, to, amount);\n		return true;\n	}\n\n	function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, allowance(owner, spender) + addedValue);\n		return true;\n	}\n\n	function decreaseAllowance(\n		address spender,\n		uint256 subtractedValue\n	) public virtual returns (bool) {\n		address owner = _msgSender();\n		uint256 currentAllowance = allowance(owner, spender);\n		require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n		unchecked {\n			_approve(owner, spender, currentAllowance - subtractedValue);\n		}\n\n		return true;\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal virtual {\n		require(from != address(0), "ERC20: transfer from the zero address");\n		require(to != address(0), "ERC20: transfer to the zero address");\n\n		_beforeTokenTransfer(from, to, amount);\n\n		uint256 fromBalance = _balances[from];\n		require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n		unchecked {\n			_balances[from] = fromBalance - amount;\n			// Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n			// decrementing then incrementing.\n			_balances[to] += amount;\n		}\n\n		emit Transfer(from, to, amount);\n\n		_afterTokenTransfer(from, to, amount);\n	}\n\n	function _mint(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: mint to the zero address");\n\n		_beforeTokenTransfer(address(0), account, amount);\n\n		_totalSupply += amount;\n		unchecked {\n			// Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n			_balances[account] += amount;\n		}\n		emit Transfer(address(0), account, amount);\n\n		_afterTokenTransfer(address(0), account, amount);\n	}\n\n	function _burn(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: burn from the zero address");\n\n		_beforeTokenTransfer(account, address(0), amount);\n\n		uint256 accountBalance = _balances[account];\n		require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n		unchecked {\n			_balances[account] = accountBalance - amount;\n			// Overflow not possible: amount <= accountBalance <= totalSupply.\n			_totalSupply -= amount;\n		}\n\n		emit Transfer(account, address(0), amount);\n\n		_afterTokenTransfer(account, address(0), amount);\n	}\n\n	function _approve(address owner, address spender, uint256 amount) internal virtual {\n		require(owner != address(0), "ERC20: approve from the zero address");\n		require(spender != address(0), "ERC20: approve to the zero address");\n\n		_allowances[owner][spender] = amount;\n		emit Approval(owner, spender, amount);\n	}\n\n	function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n		uint256 currentAllowance = allowance(owner, spender);\n		if (currentAllowance != type(uint256).max) {\n			require(currentAllowance >= amount, "ERC20: insufficient allowance");\n			unchecked {\n				_approve(owner, spender, currentAllowance - amount);\n			}\n		}\n	}\n\n	function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n	function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\ninterface IUniswapV2Factory {\n	event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n	function feeTo() external view returns (address);\n\n	function feeToSetter() external view returns (address);\n\n	function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n	function allPairs(uint) external view returns (address pair);\n\n	function allPairsLength() external view returns (uint);\n\n	function createPair(address tokenA, address tokenB) external returns (address pair);\n\n	function setFeeTo(address) external;\n\n	function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n	function factory() external pure returns (address);\n\n	function WETH() external pure returns (address);\n\n	function addLiquidity(\n		address tokenA,\n		address tokenB,\n		uint amountADesired,\n		uint amountBDesired,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB, uint liquidity);\n\n	function addLiquidityETH(\n		address token,\n		uint amountTokenDesired,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n	function removeLiquidity(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETH(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountToken, uint amountETH);\n\n	function removeLiquidityWithPermit(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETHWithPermit(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountToken, uint amountETH);\n\n	function swapExactTokensForTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapTokensForExactTokens(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactETHForTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function swapTokensForExactETH(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactTokensForETH(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapETHForExactTokens(\n		uint amountOut,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n	function getAmountOut(\n		uint amountIn,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountOut);\n\n	function getAmountIn(\n		uint amountOut,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountIn);\n\n	function getAmountsOut(\n		uint amountIn,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n\n	function getAmountsIn(\n		uint amountOut,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n	function removeLiquidityETHSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountETH);\n\n	function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountETH);\n\n	function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n\n	function swapExactETHForTokensSupportingFeeOnTransferTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable;\n\n	function swapExactTokensForETHSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n}\n\nabstract contract Ownable is Context {\n	address private _owner;\n\n	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n	constructor() {\n		_transferOwnership(_msgSender());\n	}\n\n	modifier onlyOwner() {\n		_checkOwner();\n		_;\n	}\n\n	function owner() public view virtual returns (address) {\n		return _owner;\n	}\n\n	function _checkOwner() internal view virtual {\n		require(owner() == _msgSender(), "Ownable: caller is not the owner");\n	}\n\n	function renounceOwnership() public virtual onlyOwner {\n		_transferOwnership(address(0));\n	}\n\n	function transferOwnership(address newOwner) public virtual onlyOwner {\n		require(newOwner != address(0), "Ownable: new owner is the zero address");\n		_transferOwnership(newOwner);\n	}\n\n	function _transferOwnership(address newOwner) internal virtual {\n		address oldOwner = _owner;\n		_owner = newOwner;\n		emit OwnershipTransferred(oldOwner, newOwner);\n	}\n}\n\ncontract StandardToken is ERC20, Ownable {\n	event TransferFee(uint256 makertingTax, uint256 devTax, uint256 indexed lpTax);\n	event MarketingWalletUpdated(address newWallet, address oldWallet);\n	event DevWalletUpdated(address newWallet, address oldWallet);\n\n	struct TokenInfo {\n		string name;\n		string symbol;\n		address marketingFeeReceiver;\n		address devFeeReceiver;\n		uint256 marketingTaxBuy;\n		uint256 marketingTaxSell;\n		uint256 devTaxSell;\n		uint256 devTaxBuy;\n		uint256 lpTaxBuy;\n		uint256 lpTaxSell;\n		uint256 totalSupply;\n		uint256 maxPercentageForWallet;\n		uint256 maxPercentageForTx;\n		address swapRouter;\n		address newOwner;\n	}\n\n	TokenInfo private tokenInfo;\n\n	mapping(address => bool) public isExcludeFromFee;\n	mapping(address => bool) public isExcludeFromTxLimit;\n	mapping(address => bool) public isExcludeFromWalletLimit;\n\n	address public swapPair;\n	address public weth;\n	uint256 public maxAmountForWallet;\n	uint256 public maxAmountForTx;\n\n	bool public swapping;\n\n	uint256 tokensForMarketing;\n	uint256 tokensForDev;\n	uint256 tokensForLiquidity;\n\n	modifier onlySwapping() {\n		swapping = true;\n		_;\n		swapping = false;\n	}\n\n	constructor(\n		TokenInfo memory _tokenInfo\n	) ERC20(_tokenInfo.name, _tokenInfo.symbol) payable {\n\n		tokenInfo = _tokenInfo;\n\n		require(\n			_tokenInfo.maxPercentageForTx >= 0.5 ether && _tokenInfo.maxPercentageForTx <= 100 ether,\n			"TDP4"\n		);\n		require(\n			_tokenInfo.maxPercentageForWallet >= 0.5 ether &&\n				_tokenInfo.maxPercentageForWallet <= 100 ether,\n			"TDP4"\n		);\n\n		uint256 uBuyFee = tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n		uint256 uSellFee = tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n		require(uBuyFee <= 15 ether && uSellFee <= 15 ether, "TDP1");\n\n		maxAmountForWallet = (_tokenInfo.maxPercentageForWallet * _tokenInfo.totalSupply) / 100 ether;\n		maxAmountForTx = (_tokenInfo.maxPercentageForTx * _tokenInfo.totalSupply) / 100 ether;\n\n		address swapFactory = IUniswapV2Router02(_tokenInfo.swapRouter).factory();\n		weth = IUniswapV2Router02(_tokenInfo.swapRouter).WETH();\n		swapPair = IUniswapV2Factory(swapFactory).createPair(address(this), weth);\n\n		isExcludeFromFee[address(this)] = true;\n		isExcludeFromFee[_tokenInfo.newOwner] = true;\n		isExcludeFromFee[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromFee[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromTxLimit[address(this)] = true;\n		isExcludeFromTxLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromTxLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromTxLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromTxLimit[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromWalletLimit[address(this)] = true;\n		isExcludeFromWalletLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromWalletLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromWalletLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromWalletLimit[_tokenInfo.devFeeReceiver] = true;\n		isExcludeFromWalletLimit[swapPair] = true;\n\n		super._transferOwnership(_tokenInfo.newOwner);\n		super._mint(_tokenInfo.newOwner, _tokenInfo.totalSupply);\n		_approve(address(this), tokenInfo.swapRouter, type(uint256).max);\n	}\n\n	function getTokenInfo() public view returns (TokenInfo memory _tokenInfo) {\n		_tokenInfo = tokenInfo;\n	}\n\n	function totalBuyTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n	}\n\n	function totalSellTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n	}\n\n	function totalTaxFees() public view returns (uint256) {\n		return totalBuyTaxFees() + totalSellTaxFees();\n	}\n\n	function getMarketingBuyTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxBuy;\n	}\n\n	function getMarketingSellTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxSell;\n	}\n\n	function getDevBuyTax() external view returns (uint256) {\n		return tokenInfo.devTaxBuy;\n	}\n\n	function getDevSellTax() external view returns (uint256) {\n		return tokenInfo.devTaxSell;\n	}\n\n	function getLpBuyTax() external view returns (uint256) {\n		return tokenInfo.lpTaxBuy;\n	}\n\n	function getLpSellTax() external view returns (uint256) {\n		return tokenInfo.lpTaxSell;\n	}\n\n	function setExclusionFromFee(address account, bool value) public onlyOwner {\n		isExcludeFromFee[account] = value;\n	}\n\n	function setExclusionFromTxLimit(address account, bool value) public onlyOwner {\n		isExcludeFromTxLimit[account] = value;\n	}\n\n	function setExclusionFromWalletLimit(address account, bool value) public onlyOwner {\n		isExcludeFromWalletLimit[account] = value;\n	}\n\n	function updateMarketingWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.marketingFeeReceiver = newWallet;\n		emit MarketingWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateDevWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.devFeeReceiver = newWallet;\n\n		emit DevWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateMarketingBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMarketingSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMaxWalletAmount(uint256 maxWallet) external onlyOwner {\n		require(maxWallet <= 100 ether && maxWallet >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForWallet = maxWallet;\n		maxAmountForWallet = (maxWallet * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function updateMaxTransactionAmount(uint256 maxTx) external onlyOwner {\n		require(maxTx <= 100 ether && maxTx >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForTx = maxTx;\n		maxAmountForTx = (maxTx * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function _swapAndAddLiquidity() internal onlySwapping {\n		uint256 totalFees = tokensForMarketing + tokensForDev + tokensForLiquidity;\n\n		require(totalFees > 0);\n\n		address swapRouter = tokenInfo.swapRouter;\n		uint256 halfLpFee = tokensForLiquidity / 2;\n		totalFees -= halfLpFee;\n\n		address[] memory path = new address[](2);\n		path[0] = address(this);\n		path[1] = weth;\n\n		uint256 beforeEthBalance = address(this).balance;\n\n		IUniswapV2Router02(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\n			totalFees,\n			0,\n			path,\n			address(this),\n			block.timestamp + 60\n		);\n\n		uint256 ethBalance = address(this).balance - beforeEthBalance;\n\n		uint256 lpTaxFeeETH = (ethBalance * halfLpFee) / totalFees;\n		uint256 marketingTaxFeeETH = (ethBalance * tokensForMarketing) / totalFees;\n		uint256 devTaxFeeETH = (ethBalance * tokensForDev) / totalFees;\n\n		if (marketingTaxFeeETH > 0) {\n			payable(tokenInfo.marketingFeeReceiver).transfer(marketingTaxFeeETH);\n		}\n		if (devTaxFeeETH > 0) {\n			payable(tokenInfo.devFeeReceiver).transfer(devTaxFeeETH);\n		}\n		\n\n		if (lpTaxFeeETH > 0 && halfLpFee > 0) {\n			IUniswapV2Router02(swapRouter).addLiquidityETH{ value: lpTaxFeeETH }(\n				address(this),\n				halfLpFee,\n				0,\n				0,\n				owner(),\n				block.timestamp + 60\n			);\n		}\n\n		tokensForMarketing = 0;\n		tokensForDev = 0;\n		tokensForLiquidity = 0;\n\n		emit TransferFee(tokensForMarketing, tokensForDev, tokensForLiquidity);\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal override {\n		if (!isExcludeFromTxLimit[from] && !isExcludeFromTxLimit[to])\n			require(maxAmountForTx >= amount, "TDP2");\n		if (!isExcludeFromWalletLimit[to])\n			require((balanceOf(to) + amount) <= maxAmountForWallet, "TDP3");\n\n		if (amount == 0) {\n			super._transfer(from, to, 0);\n			return;\n		}\n\n		uint256 fees;\n		if (\n			!swapping &&\n			!isExcludeFromFee[from] &&\n			!isExcludeFromFee[to] &&\n			(from == swapPair || to == swapPair)\n		) {\n			uint256 uBuyFee = totalBuyTaxFees();\n			uint256 uSellFee = totalSellTaxFees(); \n\n			if (from == swapPair && uBuyFee > 0) {\n				fees = (amount * uBuyFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxBuy) / uBuyFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxBuy) / uBuyFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxBuy) / uBuyFee;\n			}\n			if (to == swapPair && uSellFee > 0) {\n				fees = (amount * uSellFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxSell) / uSellFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxSell) / uSellFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxSell) / uSellFee;\n			}\n\n			super._transfer(from, address(this), fees);\n\n			if (to == swapPair && fees > 0) {\n				_swapAndAddLiquidity();\n			}\n		}\n\n		super._transfer(from, to, amount - fees);\n	}\n\n	receive() external payable {}\n}',chainData:i.standardToken,constructors:[{componentType:"split",text:"Token Configurations",name:"tokenconfigseperator"},{description:"",placeholder:"My Token",title:"Token Name",className:"col-md-4",name:"name",componentType:"text",order:0},{description:"",placeholder:"MTK",title:"Token Symbol",className:"col-md-4",name:"symbol",componentType:"text",order:1},{description:"",placeholder:"21000000",title:"Total Supply",className:"col-md-4",name:"totalSupply",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",order:10,decimals:18},{description:"",placeholder:"0x......",title:"Marketing Wallet",className:"col-md-6 mt-3",name:"marketingFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:2},{description:"",placeholder:"0x......",title:"Dev Wallet",className:"col-md-6 mt-3",name:"devFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:3},{componentType:"split",text:"Fee Configurations",name:"feeconfigseperator"},{description:"",placeholder:"5",title:"Marketing Buy Fee",className:"col-md-4",name:"marketingTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:4,decimals:18},{description:"",placeholder:"5",title:"Dev Buy Fee",className:"col-md-4",name:"devTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:7,decimals:18},{description:"",placeholder:"5",title:"LP Buy Fee",className:"col-md-4",name:"lpTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:8,decimals:18},{description:"",placeholder:"5",title:"Marketing Sell Fee",className:"col-md-4",name:"marketingTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:5,decimals:18},{description:"",placeholder:"5",title:"Dev Sell Fee",className:"col-md-4",name:"devTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:6,decimals:18},{description:"",placeholder:"5",title:"LP Sell Fee",className:"col-md-4",name:"lpTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:9,decimals:18},{componentType:"split",text:"Bot Settings",name:"botconfigseperator"},{description:"",placeholder:"",title:"Max Transaction Amount",className:"col-md-12",name:"maxPercentageForTx",componentType:"range",min:"0.5",max:"100",step:"0.5",order:12,decimals:18},{description:"",placeholder:"",title:"Max Wallet Amount",className:"col-md-12",name:"maxPercentageForWallet",componentType:"range",min:"0.5",max:"100",step:"0.5",order:11,decimals:18}],slug:"standard",image:"/standardtoken.png",functionsToRead:[{functionName:"name",args:[],title:"Name"},{functionName:"symbol",args:[],title:"Symbol"},{functionName:"decimals",args:[],title:"Decimals"},{functionName:"totalSupply",args:[],title:"Total Supply",decimals:!0},{functionName:"owner",args:[],title:"Owner"},{functionName:"getDevBuyTax",args:[],title:"Dev Buy Tax",decimals:!0,editFunction:"updateDevBuyTax",editArgs:[{title:"New Dev Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getDevSellTax",args:[],title:"Dev Sell Tax",decimals:!0,editFunction:"updateDevSellTax",editArgs:[{title:"New Dev Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getLpBuyTax",args:[],title:"Lp Buy Tax",decimals:!0,editFunction:"updateLpBuyTax",editArgs:[{title:"New LP Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getLpSellTax",args:[],decimals:!0,title:"Lp Sell Tax",editFunction:"updateLpSellTax",editArgs:[{title:"New LP Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingBuyTax",args:[],title:"Marketing Buy Tax",decimals:!0,editFunction:"updateMarketingBuyTax",editArgs:[{title:"New Marketing Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingSellTax",args:[],title:"Marketing Sell Tax",decimals:!0,editFunction:"updateMarketingSellTax",editArgs:[{title:"New Marketing Sell Tax",componentType:"number",decimals:!0}]},{functionName:"maxAmountForTx",args:[],title:"Max Tx Amount",decimals:!0,editFunction:"updateMaxTransactionAmount",editArgs:[{title:"New Max Tx Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"maxAmountForWallet",args:[],title:"Max Wallet Amount",decimals:!0,editFunction:"updateMaxWalletAmount",editArgs:[{title:"New Max Wallet Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"totalBuyTaxFees",title:"Total Buy Tax Fees",args:[],decimals:!0},{functionName:"totalSellTaxFees",title:"Total Sell Tax Fees",args:[],decimals:!0},{functionName:"totalTaxFees",title:"Total Tax Fees",args:[],decimals:!0},{title:"Exclude From Fee",decimals:!0,editFunction:"setExclusionFromFee",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Tx Limit",decimals:!0,editFunction:"setExclusionFromTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Wallet Limit",decimals:!0,editFunction:"setExclusionWalletTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]}]},{name:"Pausable Token",description:"Customizable Tax Fee’s and Anti-Bot. Includes Pause Feature.",tokenCode:'// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n	event Transfer(address indexed from, address indexed to, uint256 value);\n\n	event Approval(address indexed owner, address indexed spender, uint256 value);\n\n	function totalSupply() external view returns (uint256);\n\n	function balanceOf(address account) external view returns (uint256);\n\n	function transfer(address to, uint256 amount) external returns (bool);\n\n	function allowance(address owner, address spender) external view returns (uint256);\n\n	function approve(address spender, uint256 amount) external returns (bool);\n\n	function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n	function name() external view returns (string memory);\n\n	function symbol() external view returns (string memory);\n\n	function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n	function _msgSender() internal view virtual returns (address) {\n		return msg.sender;\n	}\n\n	function _msgData() internal view virtual returns (bytes calldata) {\n		return msg.data;\n	}\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n	mapping(address => uint256) private _balances;\n\n	mapping(address => mapping(address => uint256)) private _allowances;\n\n	uint256 private _totalSupply;\n\n	string private _name;\n	string private _symbol;\n\n	constructor(string memory name_, string memory symbol_) {\n		_name = name_;\n		_symbol = symbol_;\n	}\n\n	function name() public view virtual override returns (string memory) {\n		return _name;\n	}\n\n	function symbol() public view virtual override returns (string memory) {\n		return _symbol;\n	}\n\n	function decimals() public view virtual override returns (uint8) {\n		return 18;\n	}\n\n	function totalSupply() public view virtual override returns (uint256) {\n		return _totalSupply;\n	}\n\n	function balanceOf(address account) public view virtual override returns (uint256) {\n		return _balances[account];\n	}\n\n	function transfer(address to, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_transfer(owner, to, amount);\n		return true;\n	}\n\n	function allowance(\n		address owner,\n		address spender\n	) public view virtual override returns (uint256) {\n		return _allowances[owner][spender];\n	}\n\n	function approve(address spender, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, amount);\n		return true;\n	}\n\n	function transferFrom(\n		address from,\n		address to,\n		uint256 amount\n	) public virtual override returns (bool) {\n		address spender = _msgSender();\n		_spendAllowance(from, spender, amount);\n		_transfer(from, to, amount);\n		return true;\n	}\n\n	function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, allowance(owner, spender) + addedValue);\n		return true;\n	}\n\n	function decreaseAllowance(\n		address spender,\n		uint256 subtractedValue\n	) public virtual returns (bool) {\n		address owner = _msgSender();\n		uint256 currentAllowance = allowance(owner, spender);\n		require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n		unchecked {\n			_approve(owner, spender, currentAllowance - subtractedValue);\n		}\n\n		return true;\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal virtual {\n		require(from != address(0), "ERC20: transfer from the zero address");\n		require(to != address(0), "ERC20: transfer to the zero address");\n\n		_beforeTokenTransfer(from, to, amount);\n\n		uint256 fromBalance = _balances[from];\n		require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n		unchecked {\n			_balances[from] = fromBalance - amount;\n			// Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n			// decrementing then incrementing.\n			_balances[to] += amount;\n		}\n\n		emit Transfer(from, to, amount);\n\n		_afterTokenTransfer(from, to, amount);\n	}\n\n	function _mint(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: mint to the zero address");\n\n		_beforeTokenTransfer(address(0), account, amount);\n\n		_totalSupply += amount;\n		unchecked {\n			// Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n			_balances[account] += amount;\n		}\n		emit Transfer(address(0), account, amount);\n\n		_afterTokenTransfer(address(0), account, amount);\n	}\n\n	function _burn(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: burn from the zero address");\n\n		_beforeTokenTransfer(account, address(0), amount);\n\n		uint256 accountBalance = _balances[account];\n		require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n		unchecked {\n			_balances[account] = accountBalance - amount;\n			// Overflow not possible: amount <= accountBalance <= totalSupply.\n			_totalSupply -= amount;\n		}\n\n		emit Transfer(account, address(0), amount);\n\n		_afterTokenTransfer(account, address(0), amount);\n	}\n\n	function _approve(address owner, address spender, uint256 amount) internal virtual {\n		require(owner != address(0), "ERC20: approve from the zero address");\n		require(spender != address(0), "ERC20: approve to the zero address");\n\n		_allowances[owner][spender] = amount;\n		emit Approval(owner, spender, amount);\n	}\n\n	function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n		uint256 currentAllowance = allowance(owner, spender);\n		if (currentAllowance != type(uint256).max) {\n			require(currentAllowance >= amount, "ERC20: insufficient allowance");\n			unchecked {\n				_approve(owner, spender, currentAllowance - amount);\n			}\n		}\n	}\n\n	function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n	function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\ninterface IUniswapV2Factory {\n	event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n	function feeTo() external view returns (address);\n\n	function feeToSetter() external view returns (address);\n\n	function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n	function allPairs(uint) external view returns (address pair);\n\n	function allPairsLength() external view returns (uint);\n\n	function createPair(address tokenA, address tokenB) external returns (address pair);\n\n	function setFeeTo(address) external;\n\n	function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n	function factory() external pure returns (address);\n\n	function WETH() external pure returns (address);\n\n	function addLiquidity(\n		address tokenA,\n		address tokenB,\n		uint amountADesired,\n		uint amountBDesired,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB, uint liquidity);\n\n	function addLiquidityETH(\n		address token,\n		uint amountTokenDesired,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n	function removeLiquidity(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETH(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountToken, uint amountETH);\n\n	function removeLiquidityWithPermit(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETHWithPermit(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountToken, uint amountETH);\n\n	function swapExactTokensForTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapTokensForExactTokens(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactETHForTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function swapTokensForExactETH(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactTokensForETH(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapETHForExactTokens(\n		uint amountOut,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n	function getAmountOut(\n		uint amountIn,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountOut);\n\n	function getAmountIn(\n		uint amountOut,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountIn);\n\n	function getAmountsOut(\n		uint amountIn,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n\n	function getAmountsIn(\n		uint amountOut,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n	function removeLiquidityETHSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountETH);\n\n	function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountETH);\n\n	function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n\n	function swapExactETHForTokensSupportingFeeOnTransferTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable;\n\n	function swapExactTokensForETHSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n}\n\nabstract contract Ownable is Context {\n	address private _owner;\n\n	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n	constructor() {\n		_transferOwnership(_msgSender());\n	}\n\n	modifier onlyOwner() {\n		_checkOwner();\n		_;\n	}\n\n	function owner() public view virtual returns (address) {\n		return _owner;\n	}\n\n	function _checkOwner() internal view virtual {\n		require(owner() == _msgSender(), "Ownable: caller is not the owner");\n	}\n\n	function renounceOwnership() public virtual onlyOwner {\n		_transferOwnership(address(0));\n	}\n\n	function transferOwnership(address newOwner) public virtual onlyOwner {\n		require(newOwner != address(0), "Ownable: new owner is the zero address");\n		_transferOwnership(newOwner);\n	}\n\n	function _transferOwnership(address newOwner) internal virtual {\n		address oldOwner = _owner;\n		_owner = newOwner;\n		emit OwnershipTransferred(oldOwner, newOwner);\n	}\n}\n\ncontract PausableToken is ERC20, Ownable {\n	event TransferFee(uint256 makertingTax, uint256 devTax, uint256 indexed lpTax);\n	event MarketingWalletUpdated(address newWallet, address oldWallet);\n	event DevWalletUpdated(address newWallet, address oldWallet);\n    event Paused(address account);\n    event Unpaused(address account);\n\n	struct TokenInfo {\n		string name;\n		string symbol;\n		address marketingFeeReceiver;\n		address devFeeReceiver;\n		uint256 marketingTaxBuy;\n		uint256 marketingTaxSell;\n		uint256 devTaxSell;\n		uint256 devTaxBuy;\n		uint256 lpTaxBuy;\n		uint256 lpTaxSell;\n		uint256 totalSupply;\n		uint256 maxPercentageForWallet;\n		uint256 maxPercentageForTx;\n		address swapRouter;\n		address newOwner;\n	}\n\n	TokenInfo private tokenInfo;\n\n	mapping(address => bool) public isExcludeFromFee;\n	mapping(address => bool) public isExcludeFromTxLimit;\n	mapping(address => bool) public isExcludeFromWalletLimit;\n\n	address public swapPair;\n	address public weth;\n	uint256 public maxAmountForWallet;\n	uint256 public maxAmountForTx;\n    bool private _paused;\n\n	bool public swapping;\n\n	uint256 tokensForMarketing;\n	uint256 tokensForDev;\n	uint256 tokensForLiquidity;\n\n	modifier onlySwapping() {\n		swapping = true;\n		_;\n		swapping = false;\n	}\n\n\n    modifier whenNotPaused() {\n        require(!_paused, "Pausable: paused");\n        _;\n    }\n\n    modifier whenPaused() {\n        require(_paused, "Pausable: not paused");\n        _;\n    }\n\n	constructor(\n		TokenInfo memory _tokenInfo\n	) ERC20(_tokenInfo.name, _tokenInfo.symbol) payable {\n\n		tokenInfo = _tokenInfo;\n\n		require(\n			_tokenInfo.maxPercentageForTx >= 0.5 ether && _tokenInfo.maxPercentageForTx <= 100 ether,\n			"TDP4"\n		);\n		require(\n			_tokenInfo.maxPercentageForWallet >= 0.5 ether &&\n				_tokenInfo.maxPercentageForWallet <= 100 ether,\n			"TDP4"\n		);\n\n		uint256 uBuyFee = tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n		uint256 uSellFee = tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n		require(uBuyFee <= 15 ether && uSellFee <= 15 ether, "TDP1");\n\n		maxAmountForWallet = (_tokenInfo.maxPercentageForWallet * _tokenInfo.totalSupply) / 100 ether;\n		maxAmountForTx = (_tokenInfo.maxPercentageForTx * _tokenInfo.totalSupply) / 100 ether;\n\n		address swapFactory = IUniswapV2Router02(_tokenInfo.swapRouter).factory();\n		weth = IUniswapV2Router02(_tokenInfo.swapRouter).WETH();\n		swapPair = IUniswapV2Factory(swapFactory).createPair(address(this), weth);\n\n		isExcludeFromFee[address(this)] = true;\n		isExcludeFromFee[_tokenInfo.newOwner] = true;\n		isExcludeFromFee[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromFee[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromTxLimit[address(this)] = true;\n		isExcludeFromTxLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromTxLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromTxLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromTxLimit[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromWalletLimit[address(this)] = true;\n		isExcludeFromWalletLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromWalletLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromWalletLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromWalletLimit[_tokenInfo.devFeeReceiver] = true;\n		isExcludeFromWalletLimit[swapPair] = true;\n\n		super._transferOwnership(_tokenInfo.newOwner);\n		super._mint(_tokenInfo.newOwner, _tokenInfo.totalSupply);\n		_approve(address(this), tokenInfo.swapRouter, type(uint256).max);\n	}\n    function paused() public view returns (bool) {\n    return _paused;\n}\n\n    function pause() public onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n	function getTokenInfo() public view returns (TokenInfo memory _tokenInfo) {\n		_tokenInfo = tokenInfo;\n	}\n\n	function totalBuyTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n	}\n\n	function totalSellTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n	}\n\n	function totalTaxFees() public view returns (uint256) {\n		return totalBuyTaxFees() + totalSellTaxFees();\n	}\n\n	function getMarketingBuyTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxBuy;\n	}\n\n	function getMarketingSellTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxSell;\n	}\n\n	function getDevBuyTax() external view returns (uint256) {\n		return tokenInfo.devTaxBuy;\n	}\n\n	function getDevSellTax() external view returns (uint256) {\n		return tokenInfo.devTaxSell;\n	}\n\n	function getLpBuyTax() external view returns (uint256) {\n		return tokenInfo.lpTaxBuy;\n	}\n\n	function getLpSellTax() external view returns (uint256) {\n		return tokenInfo.lpTaxSell;\n	}\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override view  {\n        require(!paused(), "ERC20Pausable: token transfer while paused");\n    }\n\n	function setExclusionFromFee(address account, bool value) public onlyOwner {\n		isExcludeFromFee[account] = value;\n	}\n\n	function setExclusionFromTxLimit(address account, bool value) public onlyOwner {\n		isExcludeFromTxLimit[account] = value;\n	}\n\n	function setExclusionFromWalletLimit(address account, bool value) public onlyOwner {\n		isExcludeFromWalletLimit[account] = value;\n	}\n\n	function updateMarketingWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.marketingFeeReceiver = newWallet;\n		emit MarketingWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateDevWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.devFeeReceiver = newWallet;\n\n		emit DevWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateMarketingBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMarketingSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMaxWalletAmount(uint256 maxWallet) external onlyOwner {\n		require(maxWallet <= 100 ether && maxWallet >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForWallet = maxWallet;\n		maxAmountForWallet = (maxWallet * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function updateMaxTransactionAmount(uint256 maxTx) external onlyOwner {\n		require(maxTx <= 100 ether && maxTx >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForTx = maxTx;\n		maxAmountForTx = (maxTx * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function _swapAndAddLiquidity() internal onlySwapping {\n		uint256 totalFees = tokensForMarketing + tokensForDev + tokensForLiquidity;\n\n		require(totalFees > 0);\n\n		address swapRouter = tokenInfo.swapRouter;\n		uint256 halfLpFee = tokensForLiquidity / 2;\n		totalFees -= halfLpFee;\n\n		address[] memory path = new address[](2);\n		path[0] = address(this);\n		path[1] = weth;\n\n		uint256 beforeEthBalance = address(this).balance;\n\n		IUniswapV2Router02(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\n			totalFees,\n			0,\n			path,\n			address(this),\n			block.timestamp + 60\n		);\n\n		uint256 ethBalance = address(this).balance - beforeEthBalance;\n\n		uint256 lpTaxFeeETH = (ethBalance * halfLpFee) / totalFees;\n		uint256 marketingTaxFeeETH = (ethBalance * tokensForMarketing) / totalFees;\n		uint256 devTaxFeeETH = (ethBalance * tokensForDev) / totalFees;\n\n		if (marketingTaxFeeETH > 0) {\n			payable(tokenInfo.marketingFeeReceiver).transfer(marketingTaxFeeETH);\n		}\n		if (devTaxFeeETH > 0) {\n			payable(tokenInfo.devFeeReceiver).transfer(devTaxFeeETH);\n		}\n		\n\n		if (lpTaxFeeETH > 0 && halfLpFee > 0) {\n			IUniswapV2Router02(swapRouter).addLiquidityETH{ value: lpTaxFeeETH }(\n				address(this),\n				halfLpFee,\n				0,\n				0,\n				owner(),\n				block.timestamp + 60\n			);\n		}\n\n		tokensForMarketing = 0;\n		tokensForDev = 0;\n		tokensForLiquidity = 0;\n\n		emit TransferFee(tokensForMarketing, tokensForDev, tokensForLiquidity);\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal override {\n        _beforeTokenTransfer(from,to,amount);\n		if (!isExcludeFromTxLimit[from] && !isExcludeFromTxLimit[to])\n			require(maxAmountForTx >= amount, "TDP2");\n		if (!isExcludeFromWalletLimit[to])\n			require((balanceOf(to) + amount) <= maxAmountForWallet, "TDP3");\n\n		if (amount == 0) {\n			super._transfer(from, to, 0);\n			return;\n		}\n\n		uint256 fees;\n		if (\n			!swapping &&\n			!isExcludeFromFee[from] &&\n			!isExcludeFromFee[to] &&\n			(from == swapPair || to == swapPair)\n		) {\n			uint256 uBuyFee = totalBuyTaxFees();\n			uint256 uSellFee = totalSellTaxFees(); \n\n			if (from == swapPair && uBuyFee > 0) {\n				fees = (amount * uBuyFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxBuy) / uBuyFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxBuy) / uBuyFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxBuy) / uBuyFee;\n			}\n			if (to == swapPair && uSellFee > 0) {\n				fees = (amount * uSellFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxSell) / uSellFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxSell) / uSellFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxSell) / uSellFee;\n			}\n\n			super._transfer(from, address(this), fees);\n\n			if (to == swapPair && fees > 0) {\n				_swapAndAddLiquidity();\n			}\n		}\n\n		super._transfer(from, to, amount - fees);\n	}\n\n	receive() external payable {}\n}',feeValidation:!0,maxFee:30,abi:a.UH,bytecode:a.xg,contractName:"PausableToken",deployFeeAddress:"0x370D71435cC9882bA5682C3B1387D5A252f0CF81",encodetypes:["string","string","address","address","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","address","address"],slug:"pausable",image:"/pausabletoken.png",chainData:i.pausableToken,constructors:[{componentType:"split",text:"Token Configurations",name:"tokenconfigseperator"},{description:"",placeholder:"My Token",title:"Token Name",className:"col-md-4",name:"name",componentType:"text",order:0},{description:"",placeholder:"MTK",title:"Token Symbol",className:"col-md-4",name:"symbol",componentType:"text",order:1},{description:"",placeholder:"21000000",title:"Total Supply",className:"col-md-4",name:"totalSupply",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",order:10,decimals:18},{description:"",placeholder:"0x......",title:"Marketing Wallet",className:"col-md-6 mt-3",name:"marketingFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:2},{description:"",placeholder:"0x......",title:"Dev Wallet",className:"col-md-6 mt-3",name:"devFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:3},{componentType:"split",text:"Fee Configurations",name:"feeconfigseperator"},{description:"",placeholder:"5",title:"Marketing Buy Fee",className:"col-md-4",name:"marketingTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:4,decimals:18},{description:"",placeholder:"5",title:"Dev Buy Fee",className:"col-md-4",name:"devTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:7,decimals:18},{description:"",placeholder:"5",title:"LP Buy Fee",className:"col-md-4",name:"lpTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:8,decimals:18},{description:"",placeholder:"5",title:"Marketing Sell Fee",className:"col-md-4",name:"marketingTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:5,decimals:18},{description:"",placeholder:"5",title:"Dev Sell Fee",className:"col-md-4",name:"devTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:6,decimals:18},{description:"",placeholder:"5",title:"LP Sell Fee",className:"col-md-4",name:"lpTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:9,decimals:18},{componentType:"split",text:"Bot Settings",name:"botconfigseperator"},{description:"",placeholder:"",title:"Max Transaction Amount",className:"col-md-12",name:"maxPercentageForTx",componentType:"range",min:"0.5",max:"100",step:"0.5",order:12,decimals:18},{description:"",placeholder:"",title:"Max Wallet Amount",className:"col-md-12",name:"maxPercentageForWallet",componentType:"range",min:"0.5",max:"100",step:"0.5",order:11,decimals:18}],functionsToRead:[{functionName:"name",args:[],title:"Name"},{functionName:"symbol",args:[],title:"Symbol"},{functionName:"decimals",args:[],title:"Decimals"},{functionName:"totalSupply",args:[],title:"Total Supply",decimals:!0},{functionName:"owner",args:[],title:"Owner"},{functionName:"paused",args:[],title:"Paused"},{functionName:"getDevBuyTax",args:[],title:"Dev Buy Tax",decimals:!0,editFunction:"updateDevBuyTax",editArgs:[{title:"New Dev Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getDevSellTax",args:[],title:"Dev Sell Tax",decimals:!0,editFunction:"updateDevSellTax",editArgs:[{title:"New Dev Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getLpBuyTax",args:[],title:"Lp Buy Tax",decimals:!0,editFunction:"updateLpBuyTax",editArgs:[{title:"New LP Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getLpSellTax",args:[],decimals:!0,title:"Lp Sell Tax",editFunction:"updateLpSellTax",editArgs:[{title:"New LP Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingBuyTax",args:[],title:"Marketing Buy Tax",decimals:!0,editFunction:"updateMarketingBuyTax",editArgs:[{title:"New Marketing Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingSellTax",args:[],title:"Marketing Sell Tax",decimals:!0,editFunction:"updateMarketingSellTax",editArgs:[{title:"New Marketing Sell Tax",componentType:"number",decimals:!0}]},{functionName:"maxAmountForTx",args:[],title:"Max Tx Amount",decimals:!0,editFunction:"updateMaxTransactionAmount",editArgs:[{title:"New Max Tx Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"maxAmountForWallet",args:[],title:"Max Wallet Amount",decimals:!0,editFunction:"updateMaxWalletAmount",editArgs:[{title:"New Max Wallet Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"totalBuyTaxFees",title:"Total Buy Tax Fees",args:[],decimals:!0},{functionName:"totalSellTaxFees",title:"Total Sell Tax Fees",args:[],decimals:!0},{functionName:"totalTaxFees",title:"Total Tax Fees",args:[],decimals:!0},{title:"Exclude From Fee",decimals:!0,editFunction:"setExclusionFromFee",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Tx Limit",decimals:!0,editFunction:"setExclusionFromTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Wallet Limit",decimals:!0,editFunction:"setExclusionWalletTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Pause Token",decimals:!0,editFunction:"pause"},{title:"Unpause Token",decimals:!0,editFunction:"unpause"}]},{name:"Blacklist Token",description:"Customizable Tax Fee’s and Anti-Bot. Includes Blacklisting",feeValidation:!0,maxFee:30,abi:a.aW,bytecode:a.Jl,contractName:"BlacklistToken",deployFeeAddress:"0x370D71435cC9882bA5682C3B1387D5A252f0CF81",slug:"blacklist",image:"/blacklisttoken.png",tokenCode:'// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n	event Transfer(address indexed from, address indexed to, uint256 value);\n\n	event Approval(address indexed owner, address indexed spender, uint256 value);\n\n	function totalSupply() external view returns (uint256);\n\n	function balanceOf(address account) external view returns (uint256);\n\n	function transfer(address to, uint256 amount) external returns (bool);\n\n	function allowance(address owner, address spender) external view returns (uint256);\n\n	function approve(address spender, uint256 amount) external returns (bool);\n\n	function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n	function name() external view returns (string memory);\n\n	function symbol() external view returns (string memory);\n\n	function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n	function _msgSender() internal view virtual returns (address) {\n		return msg.sender;\n	}\n\n	function _msgData() internal view virtual returns (bytes calldata) {\n		return msg.data;\n	}\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n	mapping(address => uint256) private _balances;\n\n	mapping(address => mapping(address => uint256)) private _allowances;\n\n	uint256 private _totalSupply;\n\n	string private _name;\n	string private _symbol;\n\n	constructor(string memory name_, string memory symbol_) {\n		_name = name_;\n		_symbol = symbol_;\n	}\n\n	function name() public view virtual override returns (string memory) {\n		return _name;\n	}\n\n	function symbol() public view virtual override returns (string memory) {\n		return _symbol;\n	}\n\n	function decimals() public view virtual override returns (uint8) {\n		return 18;\n	}\n\n	function totalSupply() public view virtual override returns (uint256) {\n		return _totalSupply;\n	}\n\n	function balanceOf(address account) public view virtual override returns (uint256) {\n		return _balances[account];\n	}\n\n	function transfer(address to, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_transfer(owner, to, amount);\n		return true;\n	}\n\n	function allowance(\n		address owner,\n		address spender\n	) public view virtual override returns (uint256) {\n		return _allowances[owner][spender];\n	}\n\n	function approve(address spender, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, amount);\n		return true;\n	}\n\n	function transferFrom(\n		address from,\n		address to,\n		uint256 amount\n	) public virtual override returns (bool) {\n		address spender = _msgSender();\n		_spendAllowance(from, spender, amount);\n		_transfer(from, to, amount);\n		return true;\n	}\n\n	function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, allowance(owner, spender) + addedValue);\n		return true;\n	}\n\n	function decreaseAllowance(\n		address spender,\n		uint256 subtractedValue\n	) public virtual returns (bool) {\n		address owner = _msgSender();\n		uint256 currentAllowance = allowance(owner, spender);\n		require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n		unchecked {\n			_approve(owner, spender, currentAllowance - subtractedValue);\n		}\n\n		return true;\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal virtual {\n		require(from != address(0), "ERC20: transfer from the zero address");\n		require(to != address(0), "ERC20: transfer to the zero address");\n\n		_beforeTokenTransfer(from, to, amount);\n\n		uint256 fromBalance = _balances[from];\n		require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n		unchecked {\n			_balances[from] = fromBalance - amount;\n			// Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n			// decrementing then incrementing.\n			_balances[to] += amount;\n		}\n\n		emit Transfer(from, to, amount);\n\n		_afterTokenTransfer(from, to, amount);\n	}\n\n	function _mint(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: mint to the zero address");\n\n		_beforeTokenTransfer(address(0), account, amount);\n\n		_totalSupply += amount;\n		unchecked {\n			// Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n			_balances[account] += amount;\n		}\n		emit Transfer(address(0), account, amount);\n\n		_afterTokenTransfer(address(0), account, amount);\n	}\n\n	function _burn(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: burn from the zero address");\n\n		_beforeTokenTransfer(account, address(0), amount);\n\n		uint256 accountBalance = _balances[account];\n		require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n		unchecked {\n			_balances[account] = accountBalance - amount;\n			// Overflow not possible: amount <= accountBalance <= totalSupply.\n			_totalSupply -= amount;\n		}\n\n		emit Transfer(account, address(0), amount);\n\n		_afterTokenTransfer(account, address(0), amount);\n	}\n\n	function _approve(address owner, address spender, uint256 amount) internal virtual {\n		require(owner != address(0), "ERC20: approve from the zero address");\n		require(spender != address(0), "ERC20: approve to the zero address");\n\n		_allowances[owner][spender] = amount;\n		emit Approval(owner, spender, amount);\n	}\n\n	function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n		uint256 currentAllowance = allowance(owner, spender);\n		if (currentAllowance != type(uint256).max) {\n			require(currentAllowance >= amount, "ERC20: insufficient allowance");\n			unchecked {\n				_approve(owner, spender, currentAllowance - amount);\n			}\n		}\n	}\n\n	function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n	function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\ninterface IUniswapV2Factory {\n	event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n	function feeTo() external view returns (address);\n\n	function feeToSetter() external view returns (address);\n\n	function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n	function allPairs(uint) external view returns (address pair);\n\n	function allPairsLength() external view returns (uint);\n\n	function createPair(address tokenA, address tokenB) external returns (address pair);\n\n	function setFeeTo(address) external;\n\n	function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n	function factory() external pure returns (address);\n\n	function WETH() external pure returns (address);\n\n	function addLiquidity(\n		address tokenA,\n		address tokenB,\n		uint amountADesired,\n		uint amountBDesired,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB, uint liquidity);\n\n	function addLiquidityETH(\n		address token,\n		uint amountTokenDesired,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n	function removeLiquidity(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETH(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountToken, uint amountETH);\n\n	function removeLiquidityWithPermit(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETHWithPermit(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountToken, uint amountETH);\n\n	function swapExactTokensForTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapTokensForExactTokens(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactETHForTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function swapTokensForExactETH(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactTokensForETH(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapETHForExactTokens(\n		uint amountOut,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n	function getAmountOut(\n		uint amountIn,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountOut);\n\n	function getAmountIn(\n		uint amountOut,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountIn);\n\n	function getAmountsOut(\n		uint amountIn,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n\n	function getAmountsIn(\n		uint amountOut,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n	function removeLiquidityETHSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountETH);\n\n	function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountETH);\n\n	function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n\n	function swapExactETHForTokensSupportingFeeOnTransferTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable;\n\n	function swapExactTokensForETHSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n}\n\nabstract contract Ownable is Context {\n	address private _owner;\n\n	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n	constructor() {\n		_transferOwnership(_msgSender());\n	}\n\n	modifier onlyOwner() {\n		_checkOwner();\n		_;\n	}\n\n	function owner() public view virtual returns (address) {\n		return _owner;\n	}\n\n	function _checkOwner() internal view virtual {\n		require(owner() == _msgSender(), "Ownable: caller is not the owner");\n	}\n\n	function renounceOwnership() public virtual onlyOwner {\n		_transferOwnership(address(0));\n	}\n\n	function transferOwnership(address newOwner) public virtual onlyOwner {\n		require(newOwner != address(0), "Ownable: new owner is the zero address");\n		_transferOwnership(newOwner);\n	}\n\n	function _transferOwnership(address newOwner) internal virtual {\n		address oldOwner = _owner;\n		_owner = newOwner;\n		emit OwnershipTransferred(oldOwner, newOwner);\n	}\n}\n\ncontract BlacklistToken is ERC20, Ownable {\n	event TransferFee(uint256 makertingTax, uint256 devTax, uint256 indexed lpTax);\n	event MarketingWalletUpdated(address newWallet, address oldWallet);\n	event DevWalletUpdated(address newWallet, address oldWallet);\n    event Blacklisted(address account);\n    event Unblacklisted(address account);\n\n	struct TokenInfo {\n		string name;\n		string symbol;\n		address marketingFeeReceiver;\n		address devFeeReceiver;\n		uint256 marketingTaxBuy;\n		uint256 marketingTaxSell;\n		uint256 devTaxSell;\n		uint256 devTaxBuy;\n		uint256 lpTaxBuy;\n		uint256 lpTaxSell;\n		uint256 totalSupply;\n		uint256 maxPercentageForWallet;\n		uint256 maxPercentageForTx;\n		address swapRouter;\n		address newOwner;\n	}\n\n	TokenInfo private tokenInfo;\n\n	mapping(address => bool) public isExcludeFromFee;\n	mapping(address => bool) public isExcludeFromTxLimit;\n	mapping(address => bool) public isExcludeFromWalletLimit;\n    mapping(address => bool) private _isBlacklisted;\n\n	address public swapPair;\n	address public weth;\n	uint256 public maxAmountForWallet;\n	uint256 public maxAmountForTx;\n\n	bool public swapping;\n\n	uint256 tokensForMarketing;\n	uint256 tokensForDev;\n	uint256 tokensForLiquidity;\n\n	modifier onlySwapping() {\n		swapping = true;\n		_;\n		swapping = false;\n	}\n\n\n    modifier notBlacklisted(address account) {\n        require(!_isBlacklisted[account], "Blacklisted: account is blacklisted");\n        _;\n    }\n\n	constructor(\n		TokenInfo memory _tokenInfo\n	) ERC20(_tokenInfo.name, _tokenInfo.symbol) payable {\n	\n		tokenInfo = _tokenInfo;\n\n		require(\n			_tokenInfo.maxPercentageForTx >= 0.5 ether && _tokenInfo.maxPercentageForTx <= 100 ether,\n			"TDP4"\n		);\n		require(\n			_tokenInfo.maxPercentageForWallet >= 0.5 ether &&\n				_tokenInfo.maxPercentageForWallet <= 100 ether,\n			"TDP4"\n		);\n\n		uint256 uBuyFee = tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n		uint256 uSellFee = tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n		require(uBuyFee <= 15 ether && uSellFee <= 15 ether, "TDP1");\n\n		maxAmountForWallet = (_tokenInfo.maxPercentageForWallet * _tokenInfo.totalSupply) / 100 ether;\n		maxAmountForTx = (_tokenInfo.maxPercentageForTx * _tokenInfo.totalSupply) / 100 ether;\n\n		address swapFactory = IUniswapV2Router02(_tokenInfo.swapRouter).factory();\n		weth = IUniswapV2Router02(_tokenInfo.swapRouter).WETH();\n		swapPair = IUniswapV2Factory(swapFactory).createPair(address(this), weth);\n\n		isExcludeFromFee[address(this)] = true;\n		isExcludeFromFee[_tokenInfo.newOwner] = true;\n		isExcludeFromFee[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromFee[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromTxLimit[address(this)] = true;\n		isExcludeFromTxLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromTxLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromTxLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromTxLimit[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromWalletLimit[address(this)] = true;\n		isExcludeFromWalletLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromWalletLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromWalletLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromWalletLimit[_tokenInfo.devFeeReceiver] = true;\n		isExcludeFromWalletLimit[swapPair] = true;\n\n		super._transferOwnership(_tokenInfo.newOwner);\n		super._mint(_tokenInfo.newOwner, _tokenInfo.totalSupply);\n		_approve(address(this), tokenInfo.swapRouter, type(uint256).max);\n	}\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal view override {\n        require(!_isBlacklisted[from], "ERC20: sender is blacklisted");\n        require(!_isBlacklisted[to], "ERC20: recipient is blacklisted");\n    }\n\n	function getTokenInfo() public view returns (TokenInfo memory _tokenInfo) {\n		_tokenInfo = tokenInfo;\n	}\n\n	function totalBuyTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n	}\n\n	function totalSellTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n	}\n\n	function totalTaxFees() public view returns (uint256) {\n		return totalBuyTaxFees() + totalSellTaxFees();\n	}\n\n	function getMarketingBuyTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxBuy;\n	}\n\n	function getMarketingSellTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxSell;\n	}\n\n	function getDevBuyTax() external view returns (uint256) {\n		return tokenInfo.devTaxBuy;\n	}\n\n	function getDevSellTax() external view returns (uint256) {\n		return tokenInfo.devTaxSell;\n	}\n\n	function getLpBuyTax() external view returns (uint256) {\n		return tokenInfo.lpTaxBuy;\n	}\n\n	function getLpSellTax() external view returns (uint256) {\n		return tokenInfo.lpTaxSell;\n	}\n\n	function setExclusionFromFee(address account, bool value) public onlyOwner {\n		isExcludeFromFee[account] = value;\n	}\n\n	function setExclusionFromTxLimit(address account, bool value) public onlyOwner {\n		isExcludeFromTxLimit[account] = value;\n	}\n\n	function setExclusionFromWalletLimit(address account, bool value) public onlyOwner {\n		isExcludeFromWalletLimit[account] = value;\n	}\n\n	function updateMarketingWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.marketingFeeReceiver = newWallet;\n		emit MarketingWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateDevWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.devFeeReceiver = newWallet;\n\n		emit DevWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateMarketingBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMarketingSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMaxWalletAmount(uint256 maxWallet) external onlyOwner {\n		require(maxWallet <= 100 ether && maxWallet >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForWallet = maxWallet;\n		maxAmountForWallet = (maxWallet * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function updateMaxTransactionAmount(uint256 maxTx) external onlyOwner {\n		require(maxTx <= 100 ether && maxTx >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForTx = maxTx;\n		maxAmountForTx = (maxTx * tokenInfo.totalSupply) / 100 ether;\n	}\n\n    function isBlacklisted(address account) public view returns (bool) {\n        return _isBlacklisted[account];\n    }\n\n    function blacklist(address account) public onlyOwner {\n        _isBlacklisted[account] = true;\n        emit Blacklisted(account);\n    }\n\n    function unblacklist(address account) public onlyOwner {\n        _isBlacklisted[account] = false;\n        emit Unblacklisted(account);\n    }\n\n	function _swapAndAddLiquidity() internal onlySwapping {\n		uint256 totalFees = tokensForMarketing + tokensForDev + tokensForLiquidity;\n\n		require(totalFees > 0);\n\n		address swapRouter = tokenInfo.swapRouter;\n		uint256 halfLpFee = tokensForLiquidity / 2;\n		totalFees -= halfLpFee;\n\n		address[] memory path = new address[](2);\n		path[0] = address(this);\n		path[1] = weth;\n\n		uint256 beforeEthBalance = address(this).balance;\n\n		IUniswapV2Router02(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\n			totalFees,\n			0,\n			path,\n			address(this),\n			block.timestamp + 60\n		);\n\n		uint256 ethBalance = address(this).balance - beforeEthBalance;\n\n		uint256 lpTaxFeeETH = (ethBalance * halfLpFee) / totalFees;\n		uint256 marketingTaxFeeETH = (ethBalance * tokensForMarketing) / totalFees;\n		uint256 devTaxFeeETH = (ethBalance * tokensForDev) / totalFees;\n\n		if (marketingTaxFeeETH > 0) {\n			payable(tokenInfo.marketingFeeReceiver).transfer(marketingTaxFeeETH);\n		}\n		if (devTaxFeeETH > 0) {\n			payable(tokenInfo.devFeeReceiver).transfer(devTaxFeeETH);\n		}\n		\n\n		if (lpTaxFeeETH > 0 && halfLpFee > 0) {\n			IUniswapV2Router02(swapRouter).addLiquidityETH{ value: lpTaxFeeETH }(\n				address(this),\n				halfLpFee,\n				0,\n				0,\n				owner(),\n				block.timestamp + 60\n			);\n		}\n\n		tokensForMarketing = 0;\n		tokensForDev = 0;\n		tokensForLiquidity = 0;\n\n		emit TransferFee(tokensForMarketing, tokensForDev, tokensForLiquidity);\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal override {\n        _beforeTokenTransfer(from,to,amount);\n		if (!isExcludeFromTxLimit[from] && !isExcludeFromTxLimit[to])\n			require(maxAmountForTx >= amount, "TDP2");\n		if (!isExcludeFromWalletLimit[to])\n			require((balanceOf(to) + amount) <= maxAmountForWallet, "TDP3");\n\n		if (amount == 0) {\n			super._transfer(from, to, 0);\n			return;\n		}\n\n		uint256 fees;\n		if (\n			!swapping &&\n			!isExcludeFromFee[from] &&\n			!isExcludeFromFee[to] &&\n			(from == swapPair || to == swapPair)\n		) {\n			uint256 uBuyFee = totalBuyTaxFees();\n			uint256 uSellFee = totalSellTaxFees(); \n\n			if (from == swapPair && uBuyFee > 0) {\n				fees = (amount * uBuyFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxBuy) / uBuyFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxBuy) / uBuyFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxBuy) / uBuyFee;\n			}\n			if (to == swapPair && uSellFee > 0) {\n				fees = (amount * uSellFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxSell) / uSellFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxSell) / uSellFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxSell) / uSellFee;\n			}\n\n			super._transfer(from, address(this), fees);\n\n			if (to == swapPair && fees > 0) {\n				_swapAndAddLiquidity();\n			}\n		}\n\n		super._transfer(from, to, amount - fees);\n	}\n\n	receive() external payable {}\n}',encodetypes:["string","string","address","address","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","address","address"],chainData:i.blacklistToken,constructors:[{componentType:"split",text:"Token Configurations",name:"tokenconfigseperator"},{description:"",placeholder:"My Token",title:"Token Name",className:"col-md-4",name:"name",componentType:"text",order:0},{description:"",placeholder:"MTK",title:"Token Symbol",className:"col-md-4",name:"symbol",componentType:"text",order:1},{description:"",placeholder:"21000000",title:"Total Supply",className:"col-md-4",name:"totalSupply",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",order:10,decimals:18},{description:"",placeholder:"0x......",title:"Marketing Wallet",className:"col-md-6 mt-3",name:"marketingFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:2},{description:"",placeholder:"0x......",title:"Dev Wallet",className:"col-md-6 mt-3",name:"devFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:3},{componentType:"split",text:"Fee Configurations",name:"feeconfigseperator"},{description:"",placeholder:"5",title:"Marketing Buy Fee",className:"col-md-4",name:"marketingTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:4,decimals:18},{description:"",placeholder:"5",title:"Dev Buy Fee",className:"col-md-4",name:"devTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:7,decimals:18},{description:"",placeholder:"5",title:"LP Buy Fee",className:"col-md-4",name:"lpTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:8,decimals:18},{description:"",placeholder:"5",title:"Marketing Sell Fee",className:"col-md-4",name:"marketingTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:5,decimals:18},{description:"",placeholder:"5",title:"Dev Sell Fee",className:"col-md-4",name:"devTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:6,decimals:18},{description:"",placeholder:"5",title:"LP Sell Fee",className:"col-md-4",name:"lpTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:9,decimals:18},{componentType:"split",text:"Bot Settings",name:"botconfigseperator"},{description:"",placeholder:"",title:"Max Transaction Amount",className:"col-md-12",name:"maxPercentageForTx",componentType:"range",min:"0.5",max:"100",step:"0.5",order:12,decimals:18},{description:"",placeholder:"",title:"Max Wallet Amount",className:"col-md-12",name:"maxPercentageForWallet",componentType:"range",min:"0.5",max:"100",step:"0.5",order:11,decimals:18}],functionsToRead:[{functionName:"name",args:[],title:"Name"},{functionName:"symbol",args:[],title:"Symbol"},{functionName:"decimals",args:[],title:"Decimals"},{functionName:"totalSupply",args:[],title:"Total Supply",decimals:!0},{functionName:"owner",args:[],title:"Owner"},{functionName:"paused",args:[],title:"Paused"},{functionName:"getDevBuyTax",args:[],title:"Dev Buy Tax",decimals:!0,editFunction:"updateDevBuyTax",editArgs:[{title:"New Dev Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getDevSellTax",args:[],title:"Dev Sell Tax",decimals:!0,editFunction:"updateDevSellTax",editArgs:[{title:"New Dev Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getLpBuyTax",args:[],title:"Lp Buy Tax",decimals:!0,editFunction:"updateLpBuyTax",editArgs:[{title:"New LP Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getLpSellTax",args:[],decimals:!0,title:"Lp Sell Tax",editFunction:"updateLpSellTax",editArgs:[{title:"New LP Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingBuyTax",args:[],title:"Marketing Buy Tax",decimals:!0,editFunction:"updateMarketingBuyTax",editArgs:[{title:"New Marketing Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingSellTax",args:[],title:"Marketing Sell Tax",decimals:!0,editFunction:"updateMarketingSellTax",editArgs:[{title:"New Marketing Sell Tax",componentType:"number",decimals:!0}]},{functionName:"maxAmountForTx",args:[],title:"Max Tx Amount",decimals:!0,editFunction:"updateMaxTransactionAmount",editArgs:[{title:"New Max Tx Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"maxAmountForWallet",args:[],title:"Max Wallet Amount",decimals:!0,editFunction:"updateMaxWalletAmount",editArgs:[{title:"New Max Wallet Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"totalBuyTaxFees",title:"Total Buy Tax Fees",args:[],decimals:!0},{functionName:"totalSellTaxFees",title:"Total Sell Tax Fees",args:[],decimals:!0},{functionName:"totalTaxFees",title:"Total Tax Fees",args:[],decimals:!0},{title:"Exclude From Fee",decimals:!0,editFunction:"setExclusionFromFee",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Tx Limit",decimals:!0,editFunction:"setExclusionFromTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Wallet Limit",decimals:!0,editFunction:"setExclusionWalletTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Blacklist Wallet Address",decimals:!0,editFunction:"blacklist",editArgs:[{title:"Account",componentType:"text"}]},{title:"Unblacklist Wallet Address",decimals:!0,editFunction:"unblacklist",editArgs:[{title:"Account",componentType:"text"}]},{title:"Pause Token",decimals:!0,editFunction:"pause"},{title:"Unpause Token",decimals:!0,editFunction:"unpause"}]},{name:"Exclusive Token",description:"Combines all listed features along with additional added functions!",feeValidation:!0,maxFee:30,abi:a.xF,contractName:"ExclusiveToken",bytecode:a.zs,deployFeeAddress:"0x370D71435cC9882bA5682C3B1387D5A252f0CF81",slug:"ultimate",chainData:i.ultimateToken,tokenCode:'// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n	event Transfer(address indexed from, address indexed to, uint256 value);\n\n	event Approval(address indexed owner, address indexed spender, uint256 value);\n\n	function totalSupply() external view returns (uint256);\n\n	function balanceOf(address account) external view returns (uint256);\n\n	function transfer(address to, uint256 amount) external returns (bool);\n\n	function allowance(address owner, address spender) external view returns (uint256);\n\n	function approve(address spender, uint256 amount) external returns (bool);\n\n	function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IERC20Metadata is IERC20 {\n	function name() external view returns (string memory);\n\n	function symbol() external view returns (string memory);\n\n	function decimals() external view returns (uint8);\n}\n\nabstract contract Context {\n	function _msgSender() internal view virtual returns (address) {\n		return msg.sender;\n	}\n\n	function _msgData() internal view virtual returns (bytes calldata) {\n		return msg.data;\n	}\n}\n\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n	mapping(address => uint256) private _balances;\n\n	mapping(address => mapping(address => uint256)) private _allowances;\n\n	uint256 private _totalSupply;\n\n	string private _name;\n	string private _symbol;\n\n	constructor(string memory name_, string memory symbol_) {\n		_name = name_;\n		_symbol = symbol_;\n	}\n\n	function name() public view virtual override returns (string memory) {\n		return _name;\n	}\n\n	function symbol() public view virtual override returns (string memory) {\n		return _symbol;\n	}\n\n	function decimals() public view virtual override returns (uint8) {\n		return 18;\n	}\n\n	function totalSupply() public view virtual override returns (uint256) {\n		return _totalSupply;\n	}\n\n	function balanceOf(address account) public view virtual override returns (uint256) {\n		return _balances[account];\n	}\n\n	function transfer(address to, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_transfer(owner, to, amount);\n		return true;\n	}\n\n	function allowance(\n		address owner,\n		address spender\n	) public view virtual override returns (uint256) {\n		return _allowances[owner][spender];\n	}\n\n	function approve(address spender, uint256 amount) public virtual override returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, amount);\n		return true;\n	}\n\n	function transferFrom(\n		address from,\n		address to,\n		uint256 amount\n	) public virtual override returns (bool) {\n		address spender = _msgSender();\n		_spendAllowance(from, spender, amount);\n		_transfer(from, to, amount);\n		return true;\n	}\n\n	function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n		address owner = _msgSender();\n		_approve(owner, spender, allowance(owner, spender) + addedValue);\n		return true;\n	}\n\n	function decreaseAllowance(\n		address spender,\n		uint256 subtractedValue\n	) public virtual returns (bool) {\n		address owner = _msgSender();\n		uint256 currentAllowance = allowance(owner, spender);\n		require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n		unchecked {\n			_approve(owner, spender, currentAllowance - subtractedValue);\n		}\n\n		return true;\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal virtual {\n		require(from != address(0), "ERC20: transfer from the zero address");\n		require(to != address(0), "ERC20: transfer to the zero address");\n\n		_beforeTokenTransfer(from, to, amount);\n\n		uint256 fromBalance = _balances[from];\n		require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");\n		unchecked {\n			_balances[from] = fromBalance - amount;\n			// Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n			// decrementing then incrementing.\n			_balances[to] += amount;\n		}\n\n		emit Transfer(from, to, amount);\n\n		_afterTokenTransfer(from, to, amount);\n	}\n\n	function _mint(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: mint to the zero address");\n\n		_beforeTokenTransfer(address(0), account, amount);\n\n		_totalSupply += amount;\n		unchecked {\n			// Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n			_balances[account] += amount;\n		}\n		emit Transfer(address(0), account, amount);\n\n		_afterTokenTransfer(address(0), account, amount);\n	}\n\n	function _burn(address account, uint256 amount) internal virtual {\n		require(account != address(0), "ERC20: burn from the zero address");\n\n		_beforeTokenTransfer(account, address(0), amount);\n\n		uint256 accountBalance = _balances[account];\n		require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n		unchecked {\n			_balances[account] = accountBalance - amount;\n			// Overflow not possible: amount <= accountBalance <= totalSupply.\n			_totalSupply -= amount;\n		}\n\n		emit Transfer(account, address(0), amount);\n\n		_afterTokenTransfer(account, address(0), amount);\n	}\n\n	function _approve(address owner, address spender, uint256 amount) internal virtual {\n		require(owner != address(0), "ERC20: approve from the zero address");\n		require(spender != address(0), "ERC20: approve to the zero address");\n\n		_allowances[owner][spender] = amount;\n		emit Approval(owner, spender, amount);\n	}\n\n	function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n		uint256 currentAllowance = allowance(owner, spender);\n		if (currentAllowance != type(uint256).max) {\n			require(currentAllowance >= amount, "ERC20: insufficient allowance");\n			unchecked {\n				_approve(owner, spender, currentAllowance - amount);\n			}\n		}\n	}\n\n	function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n	function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n\ninterface IUniswapV2Factory {\n	event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n	function feeTo() external view returns (address);\n\n	function feeToSetter() external view returns (address);\n\n	function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n	function allPairs(uint) external view returns (address pair);\n\n	function allPairsLength() external view returns (uint);\n\n	function createPair(address tokenA, address tokenB) external returns (address pair);\n\n	function setFeeTo(address) external;\n\n	function setFeeToSetter(address) external;\n}\n\ninterface IUniswapV2Router01 {\n	function factory() external pure returns (address);\n\n	function WETH() external pure returns (address);\n\n	function addLiquidity(\n		address tokenA,\n		address tokenB,\n		uint amountADesired,\n		uint amountBDesired,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB, uint liquidity);\n\n	function addLiquidityETH(\n		address token,\n		uint amountTokenDesired,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n	function removeLiquidity(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETH(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountToken, uint amountETH);\n\n	function removeLiquidityWithPermit(\n		address tokenA,\n		address tokenB,\n		uint liquidity,\n		uint amountAMin,\n		uint amountBMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountA, uint amountB);\n\n	function removeLiquidityETHWithPermit(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountToken, uint amountETH);\n\n	function swapExactTokensForTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapTokensForExactTokens(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactETHForTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function swapTokensForExactETH(\n		uint amountOut,\n		uint amountInMax,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapExactTokensForETH(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external returns (uint[] memory amounts);\n\n	function swapETHForExactTokens(\n		uint amountOut,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable returns (uint[] memory amounts);\n\n	function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n	function getAmountOut(\n		uint amountIn,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountOut);\n\n	function getAmountIn(\n		uint amountOut,\n		uint reserveIn,\n		uint reserveOut\n	) external pure returns (uint amountIn);\n\n	function getAmountsOut(\n		uint amountIn,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n\n	function getAmountsIn(\n		uint amountOut,\n		address[] calldata path\n	) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n	function removeLiquidityETHSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline\n	) external returns (uint amountETH);\n\n	function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n		address token,\n		uint liquidity,\n		uint amountTokenMin,\n		uint amountETHMin,\n		address to,\n		uint deadline,\n		bool approveMax,\n		uint8 v,\n		bytes32 r,\n		bytes32 s\n	) external returns (uint amountETH);\n\n	function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n\n	function swapExactETHForTokensSupportingFeeOnTransferTokens(\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external payable;\n\n	function swapExactTokensForETHSupportingFeeOnTransferTokens(\n		uint amountIn,\n		uint amountOutMin,\n		address[] calldata path,\n		address to,\n		uint deadline\n	) external;\n}\n\nabstract contract Ownable is Context {\n	address private _owner;\n\n	event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n	constructor() {\n		_transferOwnership(_msgSender());\n	}\n\n	modifier onlyOwner() {\n		_checkOwner();\n		_;\n	}\n\n	function owner() public view virtual returns (address) {\n		return _owner;\n	}\n\n	function _checkOwner() internal view virtual {\n		require(owner() == _msgSender(), "Ownable: caller is not the owner");\n	}\n\n	function renounceOwnership() public virtual onlyOwner {\n		_transferOwnership(address(0));\n	}\n\n	function transferOwnership(address newOwner) public virtual onlyOwner {\n		require(newOwner != address(0), "Ownable: new owner is the zero address");\n		_transferOwnership(newOwner);\n	}\n\n	function _transferOwnership(address newOwner) internal virtual {\n		address oldOwner = _owner;\n		_owner = newOwner;\n		emit OwnershipTransferred(oldOwner, newOwner);\n	}\n}\n\ncontract ExclusiveToken is ERC20, Ownable {\n	event TransferFee(uint256 makertingTax, uint256 devTax, uint256 indexed lpTax);\n	event MarketingWalletUpdated(address newWallet, address oldWallet);\n	event DevWalletUpdated(address newWallet, address oldWallet);\n    event Blacklisted(address account);\n    event Unblacklisted(address account);\n    event Paused(address account);\n    event Unpaused(address account);\n\n	struct TokenInfo {\n		string name;\n		string symbol;\n		address marketingFeeReceiver;\n		address devFeeReceiver;\n		uint256 marketingTaxBuy;\n		uint256 marketingTaxSell;\n		uint256 devTaxSell;\n		uint256 devTaxBuy;\n		uint256 lpTaxBuy;\n		uint256 lpTaxSell;\n		uint256 totalSupply;\n		uint256 maxPercentageForWallet;\n		uint256 maxPercentageForTx;\n		address swapRouter;\n		address newOwner;\n	}\n\n	TokenInfo private tokenInfo;\n\n	mapping(address => bool) public isExcludeFromFee;\n	mapping(address => bool) public isExcludeFromTxLimit;\n	mapping(address => bool) public isExcludeFromWalletLimit;\n    mapping(address => bool) private _isBlacklisted;\n\n	address public swapPair;\n	address public weth;\n	uint256 public maxAmountForWallet;\n	uint256 public maxAmountForTx;\n\n	bool public swapping;\n    bool private _paused;\n\n	uint256 tokensForMarketing;\n	uint256 tokensForDev;\n	uint256 tokensForLiquidity;\n\n	modifier onlySwapping() {\n		swapping = true;\n		_;\n		swapping = false;\n	}\n\n\n    modifier notBlacklisted(address account) {\n        require(!_isBlacklisted[account], "Blacklisted: account is blacklisted");\n        _;\n    }\n\n    modifier whenNotPaused() {\n    require(!_paused, "Pausable: paused");\n        _;\n    }\n\n    modifier whenPaused() {\n    require(_paused, "Pausable: not paused");\n    _;\n    }\n\n\n	constructor(\n		TokenInfo memory _tokenInfo\n		) ERC20(_tokenInfo.name, _tokenInfo.symbol) payable {\n	\n		tokenInfo = _tokenInfo;\n\n		require(\n			_tokenInfo.maxPercentageForTx >= 0.5 ether && _tokenInfo.maxPercentageForTx <= 100 ether,\n			"TDP4"\n		);\n		require(\n			_tokenInfo.maxPercentageForWallet >= 0.5 ether &&\n				_tokenInfo.maxPercentageForWallet <= 100 ether,\n			"TDP4"\n		);\n\n		uint256 uBuyFee = tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n		uint256 uSellFee = tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n		require(uBuyFee <= 15 ether && uSellFee <= 15 ether, "TDP1");\n\n		maxAmountForWallet = (_tokenInfo.maxPercentageForWallet * _tokenInfo.totalSupply) / 100 ether;\n		maxAmountForTx = (_tokenInfo.maxPercentageForTx * _tokenInfo.totalSupply) / 100 ether;\n\n		address swapFactory = IUniswapV2Router02(_tokenInfo.swapRouter).factory();\n		weth = IUniswapV2Router02(_tokenInfo.swapRouter).WETH();\n		swapPair = IUniswapV2Factory(swapFactory).createPair(address(this), weth);\n\n		isExcludeFromFee[address(this)] = true;\n		isExcludeFromFee[_tokenInfo.newOwner] = true;\n		isExcludeFromFee[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromFee[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromTxLimit[address(this)] = true;\n		isExcludeFromTxLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromTxLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromTxLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromTxLimit[_tokenInfo.devFeeReceiver] = true;\n\n		isExcludeFromWalletLimit[address(this)] = true;\n		isExcludeFromWalletLimit[_tokenInfo.newOwner] = true;\n		isExcludeFromWalletLimit[tokenInfo.swapRouter] = true;\n		isExcludeFromWalletLimit[_tokenInfo.marketingFeeReceiver] = true;\n		isExcludeFromWalletLimit[_tokenInfo.devFeeReceiver] = true;\n		isExcludeFromWalletLimit[swapPair] = true;\n\n		super._transferOwnership(_tokenInfo.newOwner);\n		super._mint(_tokenInfo.newOwner, _tokenInfo.totalSupply);\n		_approve(address(this), tokenInfo.swapRouter, type(uint256).max);\n	}\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal view override {\n        require(!_isBlacklisted[from], "ERC20: sender is blacklisted");\n        require(!_isBlacklisted[to], "ERC20: recipient is blacklisted");\n        require(!paused(), "ERC20Pausable: token transfer while paused");\n    }\n\n	function getTokenInfo() public view returns (TokenInfo memory _tokenInfo) {\n		_tokenInfo = tokenInfo;\n	}\n\n	function totalBuyTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxBuy + tokenInfo.lpTaxBuy + tokenInfo.marketingTaxBuy;\n	}\n\n	function totalSellTaxFees() public view returns (uint256) {\n		return tokenInfo.devTaxSell + tokenInfo.lpTaxSell + tokenInfo.marketingTaxSell;\n	}\n\n	function totalTaxFees() public view returns (uint256) {\n		return totalBuyTaxFees() + totalSellTaxFees();\n	}\n\n	function getMarketingBuyTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxBuy;\n	}\n\n	function getMarketingSellTax() external view returns (uint256) {\n		return tokenInfo.marketingTaxSell;\n	}\n\n	function getDevBuyTax() external view returns (uint256) {\n		return tokenInfo.devTaxBuy;\n	}\n\n	function getDevSellTax() external view returns (uint256) {\n		return tokenInfo.devTaxSell;\n	}\n\n	function getLpBuyTax() external view returns (uint256) {\n		return tokenInfo.lpTaxBuy;\n	}\n\n	function getLpSellTax() external view returns (uint256) {\n		return tokenInfo.lpTaxSell;\n	}\n\n	function setExclusionFromFee(address account, bool value) public onlyOwner {\n		isExcludeFromFee[account] = value;\n	}\n\n	function setExclusionFromTxLimit(address account, bool value) public onlyOwner {\n		isExcludeFromTxLimit[account] = value;\n	}\n\n	function setExclusionFromWalletLimit(address account, bool value) public onlyOwner {\n		isExcludeFromWalletLimit[account] = value;\n	}\n\n	function updateMarketingWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.marketingFeeReceiver = newWallet;\n		emit MarketingWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateDevWallet(address newWallet) external onlyOwner {\n		address oldWallet = tokenInfo.marketingFeeReceiver;\n		tokenInfo.devFeeReceiver = newWallet;\n\n		emit DevWalletUpdated(newWallet, oldWallet);\n	}\n\n	function updateMarketingBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMarketingSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.marketingTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateDevSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.devTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpBuyTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxBuy = tax;\n		require(totalBuyTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateLpSellTax(uint256 tax) external onlyOwner {\n		tokenInfo.lpTaxSell = tax;\n		require(totalSellTaxFees() <= 15 ether, "TDP1");\n	}\n\n	function updateMaxWalletAmount(uint256 maxWallet) external onlyOwner {\n		require(maxWallet <= 100 ether && maxWallet >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForWallet = maxWallet;\n		maxAmountForWallet = (maxWallet * tokenInfo.totalSupply) / 100 ether;\n	}\n\n	function updateMaxTransactionAmount(uint256 maxTx) external onlyOwner {\n		require(maxTx <= 100 ether && maxTx >= 0.5 ether, "TDP4");\n		tokenInfo.maxPercentageForTx = maxTx;\n		maxAmountForTx = (maxTx * tokenInfo.totalSupply) / 100 ether;\n	}\n\n    function isBlacklisted(address account) public view returns (bool) {\n        return _isBlacklisted[account];\n    }\n\n    function blacklist(address account) public onlyOwner {\n        _isBlacklisted[account] = true;\n        emit Blacklisted(account);\n    }\n\n    function unblacklist(address account) public onlyOwner {\n        _isBlacklisted[account] = false;\n        emit Unblacklisted(account);\n    }\n\n\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    function pause() public onlyOwner whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyOwner whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n	function _swapAndAddLiquidity() internal onlySwapping {\n		uint256 totalFees = tokensForMarketing + tokensForDev + tokensForLiquidity;\n\n		require(totalFees > 0);\n\n		address swapRouter = tokenInfo.swapRouter;\n		uint256 halfLpFee = tokensForLiquidity / 2;\n		totalFees -= halfLpFee;\n\n		address[] memory path = new address[](2);\n		path[0] = address(this);\n		path[1] = weth;\n\n		uint256 beforeEthBalance = address(this).balance;\n\n		IUniswapV2Router02(swapRouter).swapExactTokensForETHSupportingFeeOnTransferTokens(\n			totalFees,\n			0,\n			path,\n			address(this),\n			block.timestamp + 60\n		);\n\n		uint256 ethBalance = address(this).balance - beforeEthBalance;\n\n		uint256 lpTaxFeeETH = (ethBalance * halfLpFee) / totalFees;\n		uint256 marketingTaxFeeETH = (ethBalance * tokensForMarketing) / totalFees;\n		uint256 devTaxFeeETH = (ethBalance * tokensForDev) / totalFees;\n\n		if (marketingTaxFeeETH > 0) {\n			payable(tokenInfo.marketingFeeReceiver).transfer(marketingTaxFeeETH);\n		}\n		if (devTaxFeeETH > 0) {\n			payable(tokenInfo.devFeeReceiver).transfer(devTaxFeeETH);\n		}\n		\n\n		if (lpTaxFeeETH > 0 && halfLpFee > 0) {\n			IUniswapV2Router02(swapRouter).addLiquidityETH{ value: lpTaxFeeETH }(\n				address(this),\n				halfLpFee,\n				0,\n				0,\n				owner(),\n				block.timestamp + 60\n			);\n		}\n\n		tokensForMarketing = 0;\n		tokensForDev = 0;\n		tokensForLiquidity = 0;\n\n		emit TransferFee(tokensForMarketing, tokensForDev, tokensForLiquidity);\n	}\n\n	function _transfer(address from, address to, uint256 amount) internal override {\n        _beforeTokenTransfer(from,to,amount);\n		if (!isExcludeFromTxLimit[from] && !isExcludeFromTxLimit[to])\n			require(maxAmountForTx >= amount, "TDP2");\n		if (!isExcludeFromWalletLimit[to])\n			require((balanceOf(to) + amount) <= maxAmountForWallet, "TDP3");\n\n		if (amount == 0) {\n			super._transfer(from, to, 0);\n			return;\n		}\n\n		uint256 fees;\n		if (\n			!swapping &&\n			!isExcludeFromFee[from] &&\n			!isExcludeFromFee[to] &&\n			(from == swapPair || to == swapPair)\n		) {\n			uint256 uBuyFee = totalBuyTaxFees();\n			uint256 uSellFee = totalSellTaxFees(); \n\n			if (from == swapPair && uBuyFee > 0) {\n				fees = (amount * uBuyFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxBuy) / uBuyFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxBuy) / uBuyFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxBuy) / uBuyFee;\n			}\n			if (to == swapPair && uSellFee > 0) {\n				fees = (amount * uSellFee) / (100 ether);\n				tokensForDev += (fees * tokenInfo.devTaxSell) / uSellFee;\n				tokensForLiquidity += (fees * tokenInfo.lpTaxSell) / uSellFee;\n				tokensForMarketing += (fees * tokenInfo.marketingTaxSell) / uSellFee;\n			}\n\n			super._transfer(from, address(this), fees);\n\n			if (to == swapPair && fees > 0) {\n				_swapAndAddLiquidity();\n			}\n		}\n\n		super._transfer(from, to, amount - fees);\n	}\n\n	receive() external payable {}\n}',image:"/exclusivetoken.png",encodetypes:["string","string","address","address","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","uint256","address","address"],constructors:[{componentType:"split",text:"Token Configurations",name:"tokenconfigseperator"},{description:"",placeholder:"My Token",title:"Token Name",className:"col-md-4",name:"name",componentType:"text",order:0},{description:"",placeholder:"MTK",title:"Token Symbol",className:"col-md-4",name:"symbol",componentType:"text",order:1},{description:"",placeholder:"21000000",title:"Total Supply",className:"col-md-4",name:"totalSupply",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",order:10,decimals:18},{description:"",placeholder:"0x......",title:"Marketing Wallet",className:"col-md-6 mt-3",name:"marketingFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:2},{description:"",placeholder:"0x......",title:"Dev Wallet",className:"col-md-6 mt-3",name:"devFeeReceiver",componentType:"text",validate:r.uc,validateMessages:" must be an Ethereum address",order:3},{componentType:"split",text:"Fee Configurations",name:"feeconfigseperator"},{description:"",placeholder:"5",title:"Marketing Buy Fee",className:"col-md-4",name:"marketingTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:4,decimals:18},{description:"",placeholder:"5",title:"Dev Buy Fee",className:"col-md-4",name:"devTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:7,decimals:18},{description:"",placeholder:"5",title:"LP Buy Fee",className:"col-md-4",name:"lpTaxBuy",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:8,decimals:18},{description:"",placeholder:"5",title:"Marketing Sell Fee",className:"col-md-4",name:"marketingTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:5,decimals:18},{description:"",placeholder:"5",title:"Dev Sell Fee",className:"col-md-4",name:"devTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:6,decimals:18},{description:"",placeholder:"5",title:"LP Sell Fee",className:"col-md-4",name:"lpTaxSell",componentType:"number",validate:r.cN,validateMessages:" must be integer and bigger than 0",fee:!0,order:9,decimals:18},{componentType:"split",text:"Bot Settings",name:"botconfigseperator"},{description:"",placeholder:"",title:"Max Transaction Amount",className:"col-md-12",name:"maxPercentageForTx",componentType:"range",min:"0.5",max:"100",step:"0.5",order:12,decimals:18},{description:"",placeholder:"",title:"Max Wallet Amount",className:"col-md-12",name:"maxPercentageForWallet",componentType:"range",min:"0.5",max:"100",step:"0.5",order:11,decimals:18}],functionsToRead:[{functionName:"name",args:[],title:"Name"},{functionName:"symbol",args:[],title:"Symbol"},{functionName:"decimals",args:[],title:"Decimals"},{functionName:"totalSupply",args:[],title:"Total Supply",decimals:!0},{functionName:"owner",args:[],title:"Owner"},{functionName:"paused",args:[],title:"Paused"},{functionName:"getDevBuyTax",args:[],title:"Dev Buy Tax",decimals:!0,editFunction:"updateDevBuyTax",editArgs:[{title:"New Dev Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getDevSellTax",args:[],title:"Dev Sell Tax",decimals:!0,editFunction:"updateDevSellTax",editArgs:[{title:"New Dev Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getLpBuyTax",args:[],title:"Lp Buy Tax",decimals:!0,editFunction:"updateLpBuyTax",editArgs:[{title:"New LP Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getLpSellTax",args:[],decimals:!0,title:"Lp Sell Tax",editFunction:"updateLpSellTax",editArgs:[{title:"New LP Sell Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingBuyTax",args:[],title:"Marketing Buy Tax",decimals:!0,editFunction:"updateMarketingBuyTax",editArgs:[{title:"New Marketing Buy Tax",componentType:"number",decimals:!0}]},{functionName:"getMarketingSellTax",args:[],title:"Marketing Sell Tax",decimals:!0,editFunction:"updateMarketingSellTax",editArgs:[{title:"New Marketing Sell Tax",componentType:"number",decimals:!0}]},{functionName:"maxAmountForTx",args:[],title:"Max Tx Amount",decimals:!0,editFunction:"updateMaxTransactionAmount",editArgs:[{title:"New Max Tx Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"maxAmountForWallet",args:[],title:"Max Wallet Amount",decimals:!0,editFunction:"updateMaxWalletAmount",editArgs:[{title:"New Max Wallet Amount Percent",componentType:"range",decimals:!0,percent:!0,min:.5,max:100,step:.5}]},{functionName:"totalBuyTaxFees",title:"Total Buy Tax Fees",args:[],decimals:!0},{functionName:"totalSellTaxFees",title:"Total Sell Tax Fees",args:[],decimals:!0},{functionName:"totalTaxFees",title:"Total Tax Fees",args:[],decimals:!0},{title:"Exclude From Fee",decimals:!0,editFunction:"setExclusionFromFee",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Tx Limit",decimals:!0,editFunction:"setExclusionFromTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Exclude From Wallet Limit",decimals:!0,editFunction:"setExclusionWalletTxLimit",editArgs:[{title:"Account",componentType:"text",order:0},{title:"Value",componentType:"switch",order:1}]},{title:"Blacklist Wallet Address",decimals:!0,editFunction:"blacklist",editArgs:[{title:"Account",componentType:"text"}]},{title:"Unblacklist Wallet Address",decimals:!0,editFunction:"unblacklist",editArgs:[{title:"Account",componentType:"text"}]},{title:"Pause Token",decimals:!0,editFunction:"pause"},{title:"Unpause Token",decimals:!0,editFunction:"unpause"}]}]}}]);